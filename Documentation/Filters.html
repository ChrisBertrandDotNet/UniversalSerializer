<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html dir="ltr" lang="en"><head>

<meta content="text/html; charset=UTF-8" http-equiv="content-type"><title>UniversalSerializer - Filters</title>
  <meta content="Christophe Bertrand" name="author"><link rel="stylesheet" href="styles.css" type="text/css">
</head><body>
<h1><a  name="mozTocId672935"></a>UniversalSerializer - Filters<br>
</h1>
<div class="table_des_matieres">
<ul  id="mozToc"><!--mozToc h1 1 h2 2 h3 3 h4 4 h5 5 h6 6-->
	<li><a href="#mozTocId622330">Available filter categories</a><ul>
		<li><a href="#mozTocId300773">Type validator filter</a></li>
		<li><a href="#mozTocId373490">Private fields adder filter</a></li>
		<li><a href="#mozTocId578924">ForcedParametricConstructorTypes</a></li>
		<li><a href="#mozTocId642133">CanTestDefaultConstructor (new in version 2.14.3)</a></li>
		<li><a href="#mozTocId205090">DefaultConstructorTestCleaner (new in version 2.14.3)</a></li>
	</ul>
	</li>
	<li><a href="#mozTocId398858">Making a set of filters [ Modified on version 3.14.5 ]</a></li>
	<li><a href="#mozTocId883671">Tool help functions</a></li>
	</ul>
</div>

<p>A filter is a function that takes a Type as a parameter and tells UniversalSerializer how to serialize it.<br>
</p>
<h2><a  name="mozTocId622330"></a>Available filter categories</h2>

<h3><a  name="mozTocId300773"></a>Type validator filter</h3>

<p>This filter allows you to prevent UniversalSerializer from serializing some problematic types.</p>

<p>For example, I met some classes using <code >System.IntPtr</code>. Serializing this type only leads to problems since they are only used internally in the classes, even when they are stored in public properties/fields.</p>

<h3><a  name="mozTocId373490"></a>Private fields adder filter</h3>

<p>This filter tells the serializer to add a particular private field to the serialization data.</p>

<p>For example, <code >System.Windows.Controls.<a href="http://msdn.microsoft.com/en-us/library/system.windows.controls.panel.aspx">Panel</a></code> needs 
<code >_uiElementCollection</code> to fill its 
<code >Children</code> property, since 
<code >Children</code> is read-only. With the filter, the solution is easy. And any type that inherits Panel, such as StackPanel, will benefit this filter.</p>

<h3><a  name="mozTocId578924"></a>ForcedParametricConstructorTypes</h3>

<p>It is not a filter but a list of types. When a type is in this list, UniversalSerializer ignores its default (not parametric) constructor and searches for a parametric constructor.<br>Example: 
<code >System.Windows.Forms.PropertyManager</code>. It is much easier to use its parametric constructor than to write a 
<code >ITypeContainer</code> for this type.</p>

<h3><a  name="mozTocId642133"></a>CanTestDefaultConstructor (new in version 2.14.3)</h3>

<p>UniversalSerializer usually tries to build one instance per type using its default constructor (when available). The problem is some types should not be constructed outside deserialization, for example when their constructor increments a static counter. This filter lets UniversalSerializer avoid this construction test.</p>

<h3><a  name="mozTocId205090"></a>DefaultConstructorTestCleaner (new in version 2.14.3)</h3>

<p>UniversalSerializer usually tries to build one instance per type using its default constructor (when available). Some types, as System.Windows.Window, needs a cleaner to be called before instance destruction.<br>In the example of WPF Window, we have to call Close(), otherwise the application will not be closed correctly (it waits for all WPF windows to be closed).</p>

<h2><a name="mozTocId398858"></a>Making a set of filters [ Modified on version 3.14.5 ]</h2>

<p class="remarque">Please note the filter mechanism is totally independent from the 
containers (<code>ITypeContainer</code>). They can be used together, or separately.</p>

<p>Let&#39;s take an example:</p>

<pre lang="cs" class="code_source">
public class ThisClassNeedsFilters
{
  public ShouldNotBeSerialized Useless;
  private int Integer;
  public string Value { get { return this.Integer.ToString(); } }

  public ThisClassNeedsFilters()
  {
  }

  public ThisClassNeedsFilters(int a)
  {
    this.Integer = a;
    this.Useless = new ShouldNotBeSerialized();
  }
}

public class ShouldNotBeSerialized
{
}</pre>

<p>This class (<code>ThisClassNeedsFilters</code>) have some problems:</p>

<ul>
	<li>It contains a <code>ShouldNotBeSerialized</code>. Let&#39;s imagine the class <code>ShouldNotBeSerialized</code> has to be avoided for some reasons, I don&#39;t know why, maybe it is poisoned!</li>
	<li>The field <code>Integer</code> is not public and therefore is ignored by the serializer(s).</li>
	<li>Even the constructor parameter name is different from any field or property. Anyway the serializer does not need this constructor, as it already has a default constructor.</li>
</ul>

<p>To overcome these problems, we write a custom set of filters:</p>

<pre lang="cs" class="code_source">
/// &lt;summary&gt;
/// Tells the serializer to add some certain private fields to store the type.
/// &lt;/summary&gt;
static FieldInfo[] MyAdditionalPrivateFieldsAdder(Type t)
{
    if (Tools.TypeIs(t, typeof(ThisClassNeedsFilters)))
        return new FieldInfo[] { Tools.FieldInfoFromName(t, &quot;Integer&quot;) };
    return null;
}
/// &lt;summary&gt;
/// Returns &#39;false&#39; if this type should not be serialized at all.
/// That will let the default value created by the constructor of its container class/structure.
/// &lt;/summary&gt;
static bool MyTypeSerializationValidator(Type t)
{
    return ! Tools.TypeIs(t, typeof(ShouldNotBeSerialized));
}</pre>

<p>They are self-explanatory:</p>

<ul>
	<li>
	<pre lang="cs" class="code_source">
FieldInfo[] MyAdditionalPrivateFieldsAdder(Type t)</pre>
	makes the serializer add a private field (<code>Integer</code>) to every source instance of this type (<code>ThisClassNeedsFilters</code>).</li>
	<li>
	<pre lang="cs" class="code_source">
bool MyTypeSerializationValidator(Type t)</pre>
	prevents the serializer from storing any instance of this type (<code>ShouldNotBeSerialized</code>). Consequently, any instance of <code>ThisClassNeedsFilters</code> will not set the <code>Useless</code> field.</li>
</ul>

<p><strong>[ New on Version 3.14.5 ]</strong> We declare the CustomModifiers :</p>

<pre lang="cs" class="code_source">
public class CustomFiltersTestModifier : CustomModifiers
{
  public CustomFiltersTestModifier()
    : base(FilterSets : new FilterSet[] {
      new FilterSet() { 
        AdditionalPrivateFieldsAdder=MyAdditionalPrivateFieldsAdder, 
        TypeSerializationValidator=MyTypeSerializationValidator } })
  {        
  }
}</pre>

<p>This declaration will automatically be found by the deserializer. [ New in version 3.14.5 ]</p>

<p>Now we serialize it: [ Simplified on Version 3.14.5 ]</p>

<pre lang="cs" class="code_source">
/* This example needs custom filters.
Normally, this class can be serialized but with wrong fields.
Thanks to these filters, we can serialize the class appropriately.
 */

using (MemoryStream ms = new MemoryStream())
{
  var p = new Parameters() { Stream = ms };
  var ser = new UniversalSerializer(p);

  var data = new ThisClassNeedsFilters(123);
  ser.Serialize(data);
  var data2 = ser.Deserialize&lt;ThisClassNeedsFilters&gt;();

  bool ok = data2.Value == &quot;123&quot; &amp;&amp; data2.Useless == null;
}</pre>

<h2><a  name="mozTocId883671"></a>Tool help functions</h2>

<p>The Tools static class offers some help:</p>

<ul>
	<li>
	<pre lang="cs" class="code_source">
Type Tools.TypeIs(Type ObjectType, Type SearchedType)</pre>
	It is equivalent to the C#&#39;s &#39;<code>is</code>&#39;, but for Types. For example, <code>TypeIs((typeof(List&lt;int&gt;)</code>, <code>typeof(List&lt;&gt;))</code> returns <code>true</code>.</li>
	<li>
	<pre lang="cs" class="code_source">
Type DerivedType(Type ObjectType, Type SearchedType)</pre>

	<p>Returns the type corresponding to <code>SearchedType</code> that is inherited by <code>ObjectType</code>. For example, <code>DerivedType(typeof(MyList), typeof(List&lt;&gt;))</code> returns <code>typeof(List&lt;int&gt;)</code> when <code>MyList</code> is</p>

	<pre lang="cs" class="code_source">
MyList: List&lt;int&gt; { }.</pre>
	</li>
	<li>
	<pre lang="cs" class="code_source">
FieldInfo FieldInfoFromName(Type t, string name)</pre>
	Returns the <code>FieldInfo</code> of the named field of the type.</li>
</ul>

<p>&nbsp;</p>

<p>&nbsp;</p>

</body></html>